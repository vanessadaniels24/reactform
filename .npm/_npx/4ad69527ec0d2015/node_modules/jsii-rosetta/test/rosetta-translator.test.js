"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const lib_1 = require("../lib");
const testutil_1 = require("./testutil");
const location = { api: { api: 'file', fileName: 'test.ts' } };
jest.setTimeout(60000);
test('translator can translate', async () => {
    const translator = new lib_1.RosettaTranslator({
        includeCompilerDiagnostics: true,
    });
    const snippet = (0, lib_1.typeScriptSnippetFromVisibleSource)('console.log("hello world");', location, true);
    const { translatedSnippets } = await translator.translateAll([snippet]);
    expect(translatedSnippets).toHaveLength(1);
    expect(translatedSnippets[0].get(lib_1.TargetLanguage.PYTHON)?.source).toEqual('print("hello world")');
    expect(translator.tablet.snippetKeys).toHaveLength(1);
});
test('translator can read from cache', async () => {
    await (0, testutil_1.withTemporaryDirectory)(async () => {
        // GIVEN: prepare cache
        const cacheBuilder = new lib_1.RosettaTranslator({ includeCompilerDiagnostics: true });
        const snippet = (0, lib_1.typeScriptSnippetFromVisibleSource)('console.log("hello world");', location, true);
        await cacheBuilder.translateAll([snippet]);
        await cacheBuilder.tablet.save('temp.tabl.json');
        // WHEN: new translatro
        const translator = new lib_1.RosettaTranslator({ includeCompilerDiagnostics: true });
        await translator.loadCache('temp.tabl.json');
        const cached = translator.readFromCache([snippet]);
        expect(cached.translations).toHaveLength(1);
        expect(cached.remaining).toHaveLength(0);
        expect(translator.tablet.snippetKeys).toHaveLength(1);
    });
});
//# sourceMappingURL=rosetta-translator.test.js.map