"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const snippet_1 = require("../lib/snippet");
const snippet_selectors_1 = require("../lib/snippet-selectors");
const tablets_1 = require("../lib/tablets/tablets");
const testutil_1 = require("./testutil");
const snippets = [];
const sources = [
    `export class ClassA {
    public someMethod() {
    }
  }`,
    `export class ClassA {
    public someMethod() {
    }
  }
  export interface BeeArgs { readonly value: string; }
  `,
    `export class ClassA {
    public someMethod() {
    }
  }
  export class ClassB {
    public argumentMethod(args: BeeArgs) {
      Array.isArray(args);
    }
  }
  export interface BeeArgs { readonly value: string; }
  `,
];
beforeAll(() => {
    for (const source of sources) {
        const snippet = tablets_1.TranslatedSnippet.fromTypeScript((0, snippet_1.typeScriptSnippetFromSource)(source, (0, testutil_1.testSnippetLocation)('selectors'), false));
        snippets.push(snippet);
    }
});
test('longest', () => {
    const result = (0, snippet_selectors_1.longest)(snippets);
    expect(result).toEqual(snippets[2]);
});
test('meanLength', () => {
    const result = (0, snippet_selectors_1.meanLength)(snippets);
    expect(result).toEqual(snippets[1]);
});
test('shortest', () => {
    const result = (0, snippet_selectors_1.shortest)(snippets);
    expect(result).toEqual(snippets[0]);
});
test('mean', () => {
    // Add fake syntax counters to ensure that snippets[1] is the closest euclidean distance.
    snippets[0].addSyntaxKindCounter({ 1: 1, 2: 5, 3: 1 });
    snippets[1].addSyntaxKindCounter({ 1: 1, 2: 3, 3: 2 });
    snippets[2].addSyntaxKindCounter({ 1: 1, 2: 1, 3: 4 });
    const result = (0, snippet_selectors_1.mean)(snippets);
    expect(result).toEqual(snippets[1]);
});
//# sourceMappingURL=snippet-selectors.test.js.map