"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const spec_1 = require("@jsii/spec");
const fs = require("fs");
const path = require("path");
const lib_1 = require("../../lib");
const extract_1 = require("../../lib/commands/extract");
const infuse_1 = require("../../lib/commands/infuse");
const assemblies_1 = require("../../lib/jsii/assemblies");
const testutil_1 = require("../testutil");
jest.setTimeout(30000);
const DUMMY_README = `
  Here is an example of how to use ClassA:

  \`\`\`ts some=metadata
  import * as ass from 'my_assembly';
  const aClass = new ass.ClassA();
  aClass.someMethod();
  \`\`\`
`;
const TABLET_FILE = 'text.tabl.json';
let assembly;
beforeEach(async () => {
    // Create an assembly in a temp directory
    assembly = testutil_1.TestJsiiModule.fromSource({
        'index.ts': `
      export class ClassA {
        public someMethod() {
        }
      }
      export class ClassB {
        public argumentMethod(args: BeeArgs) {
          Array.isArray(args);
        }
      }
      export interface BeeArgs { readonly value: string; readonly nested?: NestedType; }
      export interface NestedType { readonly x: number; }
      `,
        'README.md': DUMMY_README,
    }, {
        name: 'my_assembly',
        jsii: testutil_1.DUMMY_JSII_CONFIG,
    });
    // Create a tabletFile in the same directory
    await (0, extract_1.extractSnippets)([assembly.moduleDirectory], {
        cacheToFile: path.join(assembly.moduleDirectory, TABLET_FILE),
        includeCompilerDiagnostics: false,
        validateAssemblies: false,
    });
});
afterEach(() => assembly.cleanup());
test('examples are added in the assembly', async () => {
    await (0, infuse_1.infuse)([assembly.moduleDirectory]);
    const assemblies = (0, assemblies_1.loadAssemblies)([assembly.moduleDirectory], false);
    const types = assemblies[0].assembly.types;
    expect(types).toBeDefined();
    expect(types['my_assembly.ClassA'].docs?.example).toBeDefined();
});
test('infuse copies example metadata', async () => {
    await (0, infuse_1.infuse)([assembly.moduleDirectory]);
    // THEN: the metadata that used to be on the README snippet is also on the class example
    const updatedAssembly = (0, spec_1.loadAssemblyFromPath)(assembly.moduleDirectory);
    const typeDocs = updatedAssembly.types?.['my_assembly.ClassA']?.docs;
    expect(typeDocs?.custom?.exampleMetadata).toEqual('some=metadata infused');
});
test('examples are added to the tablet under new keys', async () => {
    const originalTabletFile = path.join(assembly.moduleDirectory, TABLET_FILE);
    const updatedTabletFile = path.join(assembly.moduleDirectory, 'tablet2.tabl.json');
    const originalDefaultTablet = await lib_1.LanguageTablet.fromFile(path.join(assembly.moduleDirectory, lib_1.DEFAULT_TABLET_NAME));
    await (0, infuse_1.infuse)([assembly.moduleDirectory], {
        cacheFromFile: originalTabletFile,
        cacheToFile: updatedTabletFile,
    });
    const originalCache = await lib_1.LanguageTablet.fromFile(originalTabletFile);
    const updatedCache = await lib_1.LanguageTablet.fromFile(updatedTabletFile);
    const updatedDefaultTablet = await lib_1.LanguageTablet.fromFile(path.join(assembly.moduleDirectory, lib_1.DEFAULT_TABLET_NAME));
    expect(updatedDefaultTablet.count).toEqual(originalDefaultTablet.count + 1);
    expect(updatedCache.count).toEqual(originalCache.count);
    expect(updatedCache.snippetKeys).not.toEqual(originalCache.snippetKeys);
});
test('can log to output file', async () => {
    await (0, infuse_1.infuse)([assembly.moduleDirectory], {
        logFile: path.join(assembly.moduleDirectory, infuse_1.DEFAULT_INFUSION_RESULTS_NAME),
    });
    // assert that the output file exists and there is some information in the file.
    const stats = await fs.promises.stat(path.join(assembly.moduleDirectory, infuse_1.DEFAULT_INFUSION_RESULTS_NAME));
    expect(stats.isFile()).toBeTruthy();
    expect(stats.size).toBeGreaterThan(0);
});
test('preserves the assembly compression if present', async () => {
    // Create an assembly in a temp directory
    const compAssembly = testutil_1.TestJsiiModule.fromSource({
        'index.ts': `
      export class ClassA {
        public someMethod() {
        }
      }
      export class ClassB {
        public argumentMethod(args: BeeArgs) {
          Array.isArray(args);
        }
      }
      export interface BeeArgs { readonly value: string; readonly nested?: NestedType; }
      export interface NestedType { readonly x: number; }
      `,
        'README.md': DUMMY_README,
    }, {
        name: 'my_assembly',
        jsii: testutil_1.DUMMY_JSII_CONFIG,
    }, {
        compressAssembly: true,
    });
    // Ensure assembly is compressed
    expect(fs.existsSync(path.join(compAssembly.moduleDirectory, spec_1.SPEC_FILE_NAME_COMPRESSED))).toBeTruthy();
    // Create a tabletFile in the same directory
    await (0, extract_1.extractSnippets)([compAssembly.moduleDirectory], {
        cacheToFile: path.join(compAssembly.moduleDirectory, TABLET_FILE),
        includeCompilerDiagnostics: false,
        validateAssemblies: false,
    });
    // Now infuse
    await (0, infuse_1.infuse)([compAssembly.moduleDirectory]);
    // Expect file at SPEC_FILE_NAME to still be a file redirect (not the actual assembly)
    expect(JSON.parse(fs.readFileSync(path.join(compAssembly.moduleDirectory, spec_1.SPEC_FILE_NAME), 'utf-8'))).toEqual({
        schema: 'jsii/file-redirect',
        compression: 'gzip',
        filename: spec_1.SPEC_FILE_NAME_COMPRESSED,
    });
    // Infuse works as expected
    const assemblies = (0, assemblies_1.loadAssemblies)([compAssembly.moduleDirectory], false);
    const types = assemblies[0].assembly.types;
    expect(types).toBeDefined();
    expect(types['my_assembly.ClassA'].docs?.example).toBeDefined();
});
test('can infuse with compressed default tablets', async () => {
    // remove any tablets that may currently exist
    const implicitTablet = path.join(assembly.moduleDirectory, lib_1.DEFAULT_TABLET_NAME);
    const compImplicitTablet = path.join(assembly.moduleDirectory, lib_1.DEFAULT_TABLET_NAME_COMPRESSED);
    await fs.promises.rm(implicitTablet, { force: true, recursive: true });
    await fs.promises.rm(compImplicitTablet, { force: true, recursive: true });
    // create a compressed implicit tablet file via extract
    await (0, extract_1.extractSnippets)([assembly.moduleDirectory], {
        includeCompilerDiagnostics: false,
        validateAssemblies: false,
        compressTablet: true,
    });
    expect(fs.existsSync(compImplicitTablet)).toBeTruthy();
    expect(fs.existsSync(implicitTablet)).toBeFalsy();
    // infuse can use compressed implicit tablets
    await (0, infuse_1.infuse)([assembly.moduleDirectory]);
    const assemblies = (0, assemblies_1.loadAssemblies)([assembly.moduleDirectory], false);
    const types = assemblies[0].assembly.types;
    expect(types).toBeDefined();
    expect(types['my_assembly.ClassA'].docs?.example).toBeDefined();
});
test('can compress cacheToFile', async () => {
    const compressedTabletFile = path.join(assembly.moduleDirectory, 'tabl.json.gz');
    await (0, infuse_1.infuse)([assembly.moduleDirectory], {
        cacheToFile: compressedTabletFile,
        compressCacheToFile: true,
    });
    const tablet = await lib_1.LanguageTablet.fromFile(compressedTabletFile);
    expect(tablet.compressedSource).toBeTruthy();
});
//# sourceMappingURL=infuse.test.js.map