"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SUPPORTED_LANGUAGES = void 0;
const fs = require("fs");
const path = require("path");
const lib_1 = require("../lib");
const languages_1 = require("../lib/languages");
const visualize_1 = require("../lib/languages/visualize");
const testutil_1 = require("./testutil");
exports.SUPPORTED_LANGUAGES = new Array({
    name: 'Python',
    extension: '.py',
    visitorFactory: languages_1.TARGET_LANGUAGES[languages_1.TargetLanguage.PYTHON],
}, {
    name: 'Java',
    extension: '.java',
    visitorFactory: languages_1.TARGET_LANGUAGES[languages_1.TargetLanguage.JAVA],
}, {
    name: 'C#',
    extension: '.cs',
    visitorFactory: languages_1.TARGET_LANGUAGES[languages_1.TargetLanguage.CSHARP],
}, {
    name: 'Go',
    extension: '.go',
    visitorFactory: languages_1.TARGET_LANGUAGES[languages_1.TargetLanguage.GO],
});
const translationsRoot = path.join(__dirname, 'translations');
const typeScriptTests = allFiles(translationsRoot)
    .filter((f) => f.endsWith('.ts') && !f.endsWith('.d.ts'))
    .filter((f) => !f.endsWith('.test.ts')); // Exclude self and other jest tests in this dir
for (const typeScriptTest of typeScriptTests) {
    describe(`Translating ${path.relative(translationsRoot, typeScriptTest)}`, () => {
        const typeScriptSource = fs.readFileSync(typeScriptTest, {
            encoding: 'utf-8',
        });
        let translator;
        let anyFailed = false;
        beforeAll(() => {
            translator = new lib_1.SnippetTranslator({
                visibleSource: typeScriptSource,
                location: (0, testutil_1.testSnippetLocation)(typeScriptTest),
            });
        });
        afterAll(() => {
            // Print the AST for tests that failed (to help debugging)
            if (anyFailed && translator) {
                const vis = translator.renderUsing(new visualize_1.VisualizeAstVisitor(true));
                console.log(`${vis}\n`);
            }
            translator = undefined; // Need this to properly release memory
        });
        for (const { name, extension, visitorFactory } of exports.SUPPORTED_LANGUAGES) {
            const languageFile = replaceExtension(typeScriptTest, extension);
            // Use 'test.skip' if the file doesn't exist so that we can clearly see it's missing.
            const testConstructor = fs.existsSync(languageFile) ? test : test.skip;
            testConstructor(`to ${name}`, () => {
                const expected = fs.readFileSync(languageFile, { encoding: 'utf-8' });
                try {
                    const translation = translator.renderUsing(visitorFactory.createVisitor());
                    expect(stripEmptyLines(translation)).toBe(stripEmptyLines(stripCommonWhitespace(expected)));
                }
                catch (e) {
                    anyFailed = true;
                    throw e;
                }
            });
        }
    });
}
function allFiles(root) {
    const ret = [];
    recurse(root);
    return ret;
    function recurse(dir) {
        for (const file of fs.readdirSync(dir)) {
            const fullPath = path.join(dir, file);
            const stat = fs.statSync(fullPath);
            if (stat.isFile()) {
                ret.push(fullPath);
            }
            if (stat.isDirectory()) {
                recurse(fullPath);
            }
        }
    }
}
function replaceExtension(x, newExtension) {
    return x.replace(/\.[^.]*$/, '') + newExtension;
}
function stripCommonWhitespace(x) {
    const lines = x.split('\n');
    const whitespaces = lines
        .filter((l) => !emptyLine(l.trim()))
        /* eslint-disable-next-line @typescript-eslint/prefer-regexp-exec */
        .map((l) => l.match(/(\s*)/)[1].length);
    const minWS = Math.min(...whitespaces);
    return lines.map((l) => l.slice(minWS)).join('\n');
}
function stripEmptyLines(x) {
    const lines = x.split('\n');
    while (lines.length > 0 && emptyLine(lines[0])) {
        lines.splice(0, 1);
    }
    while (lines.length > 0 && emptyLine(lines[lines.length - 1])) {
        lines.pop();
    }
    return lines.join('\n');
}
function emptyLine(x) {
    return x.trim() === '';
}
//# sourceMappingURL=translations.test.js.map