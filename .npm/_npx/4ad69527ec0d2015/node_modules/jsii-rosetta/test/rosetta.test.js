"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const mockfs = require("mock-fs");
const lib_1 = require("../lib");
const languages_1 = require("../lib/languages");
const fake_assembly_1 = require("./jsii/fake-assembly");
const testutil_1 = require("./testutil");
const SAMPLE_CODE = {
    visibleSource: 'callThisFunction();',
    location: (0, testutil_1.testSnippetLocation)('sample'),
};
const SAMPLE_CODE_COMPILING = {
    visibleSource: 'console.log("hello");',
    location: (0, testutil_1.testSnippetLocation)('sample'),
};
describe('Rosetta object can do live translation', () => {
    let rosetta;
    let translated;
    beforeEach(() => {
        // GIVEN
        rosetta = new lib_1.Rosetta({
            unknownSnippets: lib_1.UnknownSnippetMode.TRANSLATE,
            targetLanguages: [languages_1.TargetLanguage.PYTHON],
        });
        // WHEN
        translated = rosetta.translateSnippet(SAMPLE_CODE, languages_1.TargetLanguage.PYTHON);
    });
    test('output is correct', () => {
        expect(translated).toMatchObject({
            source: 'call_this_function()',
            language: 'python',
        });
    });
    test('translations are added to liveTablet', () => {
        expect(rosetta.liveTablet.count).toEqual(1);
    });
});
test('Can use preloaded tablet', () => {
    // GIVEN
    const rosetta = new lib_1.Rosetta();
    const tablet = new lib_1.LanguageTablet();
    tablet.addSnippet(makeSnippet(SAMPLE_CODE, {
        python: 'Not Really Translated',
        csharp: 'Not Really Translated C#',
        java: 'Not Really Translated Java',
        go: 'Not Really Translated Go',
    }));
    rosetta.addTablet(tablet);
    // WHEN
    const translated = rosetta.translateSnippet(SAMPLE_CODE, languages_1.TargetLanguage.PYTHON);
    // THEN
    expect(translated).toMatchObject({
        source: 'Not Really Translated',
        language: 'python',
    });
});
test('Rosetta object can do live translation', () => {
    // GIVEN
    const rosetta = new lib_1.Rosetta({
        unknownSnippets: lib_1.UnknownSnippetMode.TRANSLATE,
        targetLanguages: [languages_1.TargetLanguage.PYTHON],
    });
    // WHEN
    const translated = rosetta.translateSnippet(SAMPLE_CODE, languages_1.TargetLanguage.PYTHON);
    // THEN
    expect(translated).toMatchObject({
        source: 'call_this_function()',
        language: 'python',
    });
});
test('Rosetta object can fail on untranslated snippet', () => {
    // GIVEN
    const rosetta = new lib_1.Rosetta({
        unknownSnippets: lib_1.UnknownSnippetMode.FAIL,
        targetLanguages: [languages_1.TargetLanguage.PYTHON],
    });
    // WHEN
    expect(() => {
        rosetta.translateSnippet(SAMPLE_CODE, languages_1.TargetLanguage.PYTHON);
    }).toThrow(/snippet was not found/);
});
test('Rosetta can give you an untranslated snippet back', () => {
    // GIVEN
    const rosetta = new lib_1.Rosetta({
        unknownSnippets: lib_1.UnknownSnippetMode.VERBATIM,
        targetLanguages: [languages_1.TargetLanguage.PYTHON],
    });
    // WHEN
    const translated = rosetta.translateSnippet(SAMPLE_CODE, languages_1.TargetLanguage.PYTHON);
    expect(translated?.source).toEqual('callThisFunction();');
});
test('Rosetta object can do translation and annotation of snippets in MarkDown', () => {
    // GIVEN
    const rosetta = new lib_1.Rosetta({
        unknownSnippets: lib_1.UnknownSnippetMode.TRANSLATE,
        targetLanguages: [languages_1.TargetLanguage.PYTHON],
    });
    // WHEN
    const translated = rosetta.translateSnippetsInMarkdown({ api: 'file', fileName: 'markdown' }, [
        '# MarkDown Translation',
        '',
        'Now follows a snippet:',
        '```ts',
        SAMPLE_CODE.visibleSource,
        '```',
        'That was it, thank you for your attention.',
    ].join('\n'), languages_1.TargetLanguage.PYTHON, false, (trans) => {
        return {
            ...trans,
            source: `# We translated something!\n${trans.source}`,
        };
    });
    // THEN
    expect(translated).toEqual([
        '# MarkDown Translation',
        '',
        'Now follows a snippet:',
        '',
        '```python',
        '# We translated something!',
        'call_this_function()',
        '```',
        '',
        'That was it, thank you for your attention.',
    ].join('\n'));
});
describe('Rosetta object with disclaimers', () => {
    let rosetta;
    beforeEach(() => {
        // GIVEN
        rosetta = new lib_1.Rosetta({
            includeCompilerDiagnostics: true,
            unknownSnippets: lib_1.UnknownSnippetMode.TRANSLATE,
            targetLanguages: [languages_1.TargetLanguage.PYTHON],
            prefixDisclaimer: true,
        });
    });
    test('compiling source code has no disclaimer', () => {
        // WHEN
        const translated = rosetta.translateSnippet(SAMPLE_CODE_COMPILING, languages_1.TargetLanguage.PYTHON);
        // THEN
        expect(translated).toMatchObject({
            source: 'print("hello")',
            language: 'python',
        });
    });
    test('noncompiling source code has disclaimer', () => {
        // WHEN
        const translated = rosetta.translateSnippet(SAMPLE_CODE, languages_1.TargetLanguage.PYTHON);
        // THEN
        expect(translated).toMatchObject({
            source: '# Example automatically generated from non-compiling source. May contain errors.\ncall_this_function()',
            language: 'python',
        });
    });
    test('source with no compilation information has no disclaimer', () => {
        // GIVEN
        const rosettaNoCompile = new lib_1.Rosetta({
            includeCompilerDiagnostics: false,
            unknownSnippets: lib_1.UnknownSnippetMode.TRANSLATE,
            targetLanguages: [languages_1.TargetLanguage.PYTHON],
            prefixDisclaimer: true,
        });
        // WHEN
        const translated = rosettaNoCompile.translateSnippet(SAMPLE_CODE, languages_1.TargetLanguage.PYTHON);
        // THEN
        expect(translated).toMatchObject({
            source: 'call_this_function()',
            language: 'python',
        });
    });
});
describe('with mocked filesystem', () => {
    beforeEach(() => {
        mockfs();
    });
    afterEach(() => {
        mockfs.restore();
    });
    const tablet = new lib_1.LanguageTablet();
    tablet.addSnippet(makeSnippet(SAMPLE_CODE, {
        python: 'My Stored Translation',
        csharp: 'My Stored Translation C#',
        java: 'My Stored Translation Java',
        go: 'My Stored Translation Go',
    }));
    test('Can save language tablet and load it in Rosetta class', async () => {
        // GIVEN
        await tablet.save('/test.tablet');
        // WHEN
        const rosetta = new lib_1.Rosetta();
        await rosetta.loadTabletFromFile('/test.tablet');
        const translated = rosetta.translateSnippet(SAMPLE_CODE, languages_1.TargetLanguage.PYTHON);
        // THEN
        expect(translated).toMatchObject({
            source: 'My Stored Translation',
            language: 'python',
        });
    });
    test('Rosetta class automatically loads default-named tablets in same directory as assembly', async () => {
        // GIVEN
        await tablet.save(`/${lib_1.DEFAULT_TABLET_NAME}`);
        // WHEN
        const rosetta = new lib_1.Rosetta();
        await rosetta.addAssembly((0, fake_assembly_1.fakeAssembly)({}), '/');
        const translated = rosetta.translateSnippet(SAMPLE_CODE, languages_1.TargetLanguage.PYTHON);
        // THEN
        expect(translated).toMatchObject({
            source: 'My Stored Translation',
            language: 'python',
        });
    });
});
function makeSnippet(original, translations) {
    const snippet = lib_1.TranslatedSnippet.fromTypeScript(original);
    for (const [key, value] of Object.entries(translations)) {
        snippet.addTranslation(key, value, 'x');
    }
    return snippet;
}
//# sourceMappingURL=rosetta.test.js.map