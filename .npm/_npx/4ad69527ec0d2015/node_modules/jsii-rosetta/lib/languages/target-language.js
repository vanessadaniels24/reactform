"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.supportsTransitiveSubmoduleAccess = exports.targetName = exports.TargetLanguage = void 0;
const assert = require("assert");
var TargetLanguage;
(function (TargetLanguage) {
    /** @internal an alias of PYTHON to make intent clear when language is irrelevant */
    TargetLanguage["VISUALIZE"] = "python";
    // eslint-disable-next-line @typescript-eslint/no-duplicate-enum-values
    TargetLanguage["PYTHON"] = "python";
    TargetLanguage["CSHARP"] = "csharp";
    TargetLanguage["JAVA"] = "java";
    TargetLanguage["GO"] = "go";
})(TargetLanguage = exports.TargetLanguage || (exports.TargetLanguage = {}));
const VALID_TARGET_LANGUAGES = new Set(Object.values(TargetLanguage));
/**
 * @param language a possible value for `TargetLanguage`.
 *
 * @returns the name of the target configuration block for the given language.
 */
function targetName(language) {
    // The TypeScript compiler should guarantee the below `switch` statement covers all possible
    // values of the TargetLanguage enum, but we add an assert here for clarity of intent.
    assert(VALID_TARGET_LANGUAGES.has(language), `Invalid/unexpected target language identifier: ${language}`);
    switch (language) {
        case TargetLanguage.VISUALIZE:
        case TargetLanguage.PYTHON:
            return 'python';
        case TargetLanguage.CSHARP:
            return 'dotnet';
        case TargetLanguage.JAVA:
            return 'java';
        case TargetLanguage.GO:
            return 'go';
    }
}
exports.targetName = targetName;
/**
 * Determines whether the supplied language supports transitive submodule
 * access (similar to how TypeScript/Javascript allows to use a partially
 * qualified name to access a namespace-nested value).
 *
 * If `true`, imports will mirror those found in the original TypeScript
 * code, namespace-traversing property accesses will be rendered as such. This
 * means the following snippet would be transformed "as-is":
 * ```ts
 * import * as cdk from 'aws-cdk-lib';
 * new cdk.aws_s3.Bucket(this, 'Bucket');
 * ```
 *
 * If `false` on the other hand, each used submodule will be imported
 * separately and namespace-traversing property accesses will be replaced with
 * references to the separately-imported submodule. This means the above
 * snippet would be transformed as if it had been modifired to:
 * ```ts
 * import * as aws_s3 from 'aws-cdk-lib/aws-s3';
 * new aws_s3.Bucket(this, 'Bucket');
 * ```
 */
function supportsTransitiveSubmoduleAccess(language) {
    switch (language) {
        case TargetLanguage.PYTHON:
            return true;
        case TargetLanguage.CSHARP:
            return true;
        case TargetLanguage.JAVA:
            return false;
        case TargetLanguage.GO:
            return false;
    }
}
exports.supportsTransitiveSubmoduleAccess = supportsTransitiveSubmoduleAccess;
//# sourceMappingURL=target-language.js.map