"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const types_versions_1 = require("../lib/types-versions");
test('no configuration', () => {
    expect((0, types_versions_1.undoTypesVersionsRedirect)('test/path/index.ts', undefined)).toBe('test/path/index.ts');
});
test('no candidate matches', () => {
    expect((0, types_versions_1.undoTypesVersionsRedirect)('test/path/index.ts', {
        '*': { '*': ['.types-versions/ts3.9/*'] },
    })).toBe('test/path/index.ts');
});
test('incompatible-typescript-version', () => {
    expect((0, types_versions_1.undoTypesVersionsRedirect)('test/path/index.ts', {
        '>99.99.99': {
            '*': ['test/*'],
        },
    })).toBe('test/path/index.ts');
});
test('simple match', () => {
    expect((0, types_versions_1.undoTypesVersionsRedirect)('test/path/index.ts', {
        '*': {
            '*': ['test/*/index.ts'],
        },
    })).toBe('path');
});
test('multiple typeScript versions (first one wins)', () => {
    expect((0, types_versions_1.undoTypesVersionsRedirect)('test/path/index.ts', {
        '>=0': {
            '*': ['test/*/index.ts'],
        },
        '*': {
            'before/*/after.ts': ['test/*/index.ts'],
        },
    })).toBe('path');
});
test('prefix+suffix match', () => {
    expect((0, types_versions_1.undoTypesVersionsRedirect)('test/path/index.ts', {
        '*': {
            'before/*/after.ts': ['test/*/index.ts'],
        },
    })).toBe('before/path/after.ts');
});
test('multiple candidates (first match wins)', () => {
    expect((0, types_versions_1.undoTypesVersionsRedirect)('test/path/index.ts', {
        '*': {
            'before/*/after.ts': ['*/path/index.ts', 'test/*/index.ts'],
        },
    })).toBe('before/test/after.ts');
});
//# sourceMappingURL=types-versions.test.js.map