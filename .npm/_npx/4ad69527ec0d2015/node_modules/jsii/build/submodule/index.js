"use strict";
var _a, _b;
Object.defineProperty(exports, "__esModule", { value: true });
exports.NestingClass = exports.Reflector = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
class Reflector {
    asMap(reflectable) {
        return reflectable.entries.reduce((mapping, entry) => {
            mapping[entry.key] = entry.value;
            return mapping;
        }, {});
    }
}
exports.Reflector = Reflector;
_a = JSII_RTTI_SYMBOL_1;
Reflector[_a] = { fqn: "@scope/jsii-calc-lib.submodule.Reflector", version: "0.0.0" };
/**
 * This class is here to show we can use nested classes across module boundaries.
 */
class NestingClass {
    constructor() { }
}
exports.NestingClass = NestingClass;
_b = JSII_RTTI_SYMBOL_1;
NestingClass[_b] = { fqn: "@scope/jsii-calc-lib.submodule.NestingClass", version: "0.0.0" };
// eslint-disable-next-line @typescript-eslint/no-namespace
(function (NestingClass) {
    var _c;
    /**
     * This class is here to show we can use nested classes across module boundaries.
     */
    class NestedClass {
        constructor() {
            this.property = 'property';
        }
    }
    _c = JSII_RTTI_SYMBOL_1;
    NestedClass[_c] = { fqn: "@scope/jsii-calc-lib.submodule.NestingClass.NestedClass", version: "0.0.0" };
    NestingClass.NestedClass = NestedClass;
})(NestingClass = exports.NestingClass || (exports.NestingClass = {}));
